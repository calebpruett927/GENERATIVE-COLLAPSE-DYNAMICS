# Kinematics CasePack Embedding Configuration
# Defines normalization mapping from physical to bounded [0,1] coordinates

schema: "schemas/embedding.schema.json"

embedding:
  id: "KIN.EMBEDDING.v1"
  contract: "KIN.INTSTACK.v1"
  description: "Normalization embedding for kinematics observables"
  
  # Domain bounds
  domain:
    interval: [0.0, 1.0]
    face: "pre_clip"
    oor_policy: "clip_and_flag"
    epsilon: 1.0e-8

  # Reference scales for normalization
  reference_scales:
    L_ref: 10.0       # Reference length [m]
    v_ref: 10.0       # Reference velocity [m/s]
    a_ref: 9.81       # Reference acceleration [m/s²] (1g)
    m_ref: 1.0        # Reference mass [kg]
    t_ref: 1.0        # Reference time [s]
    E_ref: 100.0      # Reference energy [J]
    p_ref: 10.0       # Reference momentum [kg·m/s]
    L_ang_ref: 10.0   # Reference angular momentum [kg·m²/s]
    omega_ref: 6.283  # Reference angular velocity [rad/s] (1 rev/s)
    alpha_ref: 6.283  # Reference angular acceleration [rad/s²]
    T_ref: 10.0       # Reference torque [N·m]

  # Coordinate mappings
  mappings:
    # Linear position: x_norm = x_phys / L_ref, clipped to [0,1]
    position:
      formula: "x_norm = clip(x_phys / L_ref, 0, 1)"
      inverse: "x_phys = x_norm * L_ref"
      notes: "Position normalized by reference length"
      
    # Linear velocity: v_norm = |v_phys| / v_ref, clipped to [0,1]
    velocity:
      formula: "v_norm = clip(|v_phys| / v_ref, 0, 1)"
      inverse: "v_phys = v_norm * v_ref"
      notes: "Velocity magnitude normalized by reference velocity"
      
    # Linear acceleration: a_norm = |a_phys| / a_ref, clipped to [0,1]
    acceleration:
      formula: "a_norm = clip(|a_phys| / a_ref, 0, 1)"
      inverse: "a_phys = a_norm * a_ref"
      notes: "Acceleration magnitude normalized by reference (1g)"
      
    # Angular position: θ_norm = θ_phys / (2π), clipped to [0,1]
    angular_position:
      formula: "theta_norm = clip(theta_phys / (2*pi), 0, 1)"
      inverse: "theta_phys = theta_norm * 2 * pi"
      notes: "Angular position normalized to single revolution"
      
    # Angular velocity: ω_norm = |ω_phys| / ω_ref, clipped to [0,1]
    angular_velocity:
      formula: "omega_norm = clip(|omega_phys| / omega_ref, 0, 1)"
      inverse: "omega_phys = omega_norm * omega_ref"
      notes: "Angular velocity normalized by reference"
      
    # Energy: E_norm = E_phys / E_ref, clipped to [0,1]
    energy:
      formula: "E_norm = clip(E_phys / E_ref, 0, 1)"
      inverse: "E_phys = E_norm * E_ref"
      notes: "Energy normalized by reference"
      
    # Momentum: p_norm = p_phys / p_ref, clipped to [0,1]
    momentum:
      formula: "p_norm = clip(p_phys / p_ref, 0, 1)"
      inverse: "p_phys = p_norm * p_ref"
      notes: "Momentum normalized by reference"

  # Coordinate weights (for computing UMCP invariants)
  weights:
    default:
      description: "Equal weights for all coordinates"
      values: "uniform"
    motion_priority:
      description: "Higher weight on velocity (motion indicator)"
      x: 0.2
      v: 0.5
      a: 0.3

  # Return detection parameters
  return_settings:
    eta_position: 0.01    # Position return tolerance
    eta_velocity: 0.05    # Velocity return tolerance
    eta_phase: 0.05       # Combined phase space tolerance
    H_rec_kin: 64         # Kinematic return horizon
    min_delay: 2          # Minimum delay for return detection
    metric: "euclidean"   # Distance metric in phase space
