from __future__ import annotations

import csv
import json
import math
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]  # repo root (casepacks/hello_world/..)
CASEPACK = Path(__file__).resolve().parent
EXPECTED = CASEPACK / "expected"

RAW = CASEPACK / "raw_measurements.csv"
PSI_CSV = EXPECTED / "psi.csv"
INV_JSON = EXPECTED / "invariants.json"

# Minimal embedding for hello_world:
# x_k in [0,10] -> c_k = clip(x_k/10, 0, 1)
A = 0.0
B = 10.0
EPS = 1.0e-8


def clip01(x: float) -> float:
    return 0.0 if x < 0.0 else (1.0 if x > 1.0 else x)


def log_safe(c: float) -> float:
    return min(1.0 - EPS, max(EPS, c))


def main() -> None:
    EXPECTED.mkdir(parents=True, exist_ok=True)

    # Read raw
    with RAW.open("r", encoding="utf-8", newline="") as f:
        r = next(csv.DictReader(f))

    t = int(r["t"])
    xs = [float(r["x1_si"]), float(r["x2_si"]), float(r["x3_si"])]

    # Embed -> psi coords
    cs = [clip01((x - A) / (B - A)) for x in xs]

    # Write psi.csv (wide)
    with PSI_CSV.open("w", encoding="utf-8", newline="") as f:
        w = csv.writer(f)
        w.writerow(["t", "c_1", "c_2", "c_3", "oor_1", "oor_2", "oor_3", "miss_1", "miss_2", "miss_3"])
        oor = [("true" if (c < 0.0 or c > 1.0) else "false") for c in cs]  # after clip, always false
        miss = ["false", "false", "false"]
        w.writerow([t, cs[0], cs[1], cs[2], oor[0], oor[1], oor[2], miss[0], miss[1], miss[2]])

    # Compute invariants with uniform weights
    n = len(cs)
    wts = [1.0 / n] * n
    F = sum(wts[i] * cs[i] for i in range(n))
    omega = 1.0 - F

    # Entropy-like S: -Σ w_i [ c ln c + (1-c) ln(1-c) ]
    S = 0.0
    for i in range(n):
        c = log_safe(cs[i])
        S += wts[i] * (c * math.log(c) + (1.0 - c) * math.log(1.0 - c))
    S = -S

    # Curvature proxy C: stddev(c_i)/0.5 (population std)
    mean_c = sum(cs) / n
    var = sum((c - mean_c) ** 2 for c in cs) / n
    std = math.sqrt(var)
    C = std / 0.5

    # κ = Σ w_i ln(c_i) ; IC = exp(κ)
    kappa = sum(wts[i] * math.log(log_safe(cs[i])) for i in range(n))
    IC = math.exp(kappa)

    inv = {
        "schema": "schemas/invariants.schema.json",
        "format": "tier1_invariants",
        "contract_id": "UMA.INTSTACK.v1",
        "closure_registry_id": "UMCP.CLOSURES.DEFAULT.v1",
        "canon": {
            "pre_doi": "10.5281/zenodo.17756705",
            "post_doi": "10.5281/zenodo.18072852",
            "weld_id": "W-2025-12-31-PHYS-COHERENCE",
            "timezone": "America/Chicago",
        },
        "rows": [
            {
                "t": t,
                "omega": omega,
                "F": F,
                "S": S,
                "C": C,
                "tau_R": "INF_REC",
                "kappa": kappa,
                "IC": IC,
                "regime": {
                    "label": "Stable"
                    if (omega < 0.038 and F > 0.90 and S < 0.15 and C < 0.14)
                    else ("Collapse" if omega >= 0.30 else "Watch"),
                    "critical_overlay": False,
                },
                "kernel_optional": {"IC_min": min(cs)},
            }
        ],
        "notes": "Generated by casepacks/hello_world/generate_expected.py",
    }

    with INV_JSON.open("w", encoding="utf-8") as f:
        json.dump(inv, f, indent=2)

    print("Wrote:", PSI_CSV)
    print("Wrote:", INV_JSON)


if __name__ == "__main__":
    main()
