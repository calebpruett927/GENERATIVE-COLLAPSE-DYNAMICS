#!/usr/bin/env python3
"""
Automated integrity checksum updater for UMCP repository.

This script scans all tracked Python files and critical YAML/JSON files,
computes their SHA256 checksums, and updates integrity/sha256.txt automatically.

It tracks:
- All Python files in src/umcp/
- Contract YAML files in contracts/
- Closure Python files in closures/
- Schema JSON files in schemas/
- Key scripts in scripts/

Files are automatically added/removed from the checksum manifest as they change.
"""

from __future__ import annotations

import hashlib
import subprocess
import sys
from collections.abc import Iterator
from pathlib import Path


def get_repo_root() -> Path:
    """Find the repository root (contains pyproject.toml)."""
    current = Path.cwd()
    while current != current.parent:
        if (current / "pyproject.toml").exists():
            return current
        current = current.parent
    return Path.cwd()


def sha256sum(filepath: Path) -> str:
    """Compute SHA256 checksum of a file."""
    h = hashlib.sha256()
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()


def get_tracked_files(root: Path) -> Iterator[Path]:
    """
    Get all git-tracked files that should be checksummed.

    Includes:
    - All Python files in src/umcp/
    - Contract YAML files in contracts/
    - Closure Python files in closures/
    - Schema JSON files in schemas/
    - Script files in scripts/ (including benchmark)
    """
    try:
        # Get all git-tracked files
        result = subprocess.run(["git", "ls-files"], cwd=root, capture_output=True, text=True, check=True)
        tracked = result.stdout.strip().split("\n")

        # Filter to relevant files
        patterns = [
            "src/umcp/**/*.py",
            "contracts/**/*.yaml",
            "closures/**/*.py",
            "schemas/**/*.json",
            "scripts/**/*.py",
        ]

        for filepath_str in tracked:
            filepath = root / filepath_str
            if not filepath.exists():
                continue

            # Check if file matches any pattern
            for pattern in patterns:
                if filepath.match(pattern):
                    yield filepath
                    break

    except subprocess.CalledProcessError:
        # Fallback: scan filesystem directly
        print("Warning: git not available, scanning filesystem directly", file=sys.stderr)

        for pattern in [
            "src/umcp/**/*.py",
            "contracts/**/*.yaml",
            "closures/**/*.py",
            "schemas/**/*.json",
            "scripts/**/*.py",
        ]:
            yield from root.glob(pattern)

        # scripts/ already covered by pattern above


def main() -> int:
    """Update integrity/sha256.txt with current checksums."""
    root = get_repo_root()
    integrity_dir = root / "integrity"
    integrity_file = integrity_dir / "sha256.txt"

    # Ensure integrity directory exists
    integrity_dir.mkdir(exist_ok=True)

    # Compute checksums for all tracked files
    checksums: list[tuple[str, str]] = []  # (relative_path_str, checksum)

    for filepath in sorted(get_tracked_files(root)):
        try:
            checksum = sha256sum(filepath)
            rel_path = filepath.relative_to(root)
            checksums.append((str(rel_path), checksum))
        except Exception as e:
            print(f"Warning: Could not checksum {filepath}: {e}", file=sys.stderr)
            continue

    if not checksums:
        print("Warning: No files found to checksum", file=sys.stderr)
        return 1

    # Write checksums to integrity file
    with open(integrity_file, "w", encoding="utf-8") as f:
        f.write("# SHA256 checksums for UMCP repository files\n")
        f.write("# Auto-generated by scripts/update_integrity.py\n")
        f.write(f"# Total files: {len(checksums)}\n")
        f.write("#\n")
        f.write("# Format: <checksum> <relative_path>\n")
        f.write("#\n\n")

        for rel_path, checksum in checksums:
            f.write(f"{checksum}  {rel_path}\n")

    print(f"âœ“ Updated {integrity_file}")
    print(f"  Checksummed {len(checksums)} files")
    return 0


if __name__ == "__main__":
    sys.exit(main())
